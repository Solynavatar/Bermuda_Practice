# Project 1

## 一、SM4 算法大致原理

SM4 是中国国家密码管理局制定的分组密码标准，采用分组长度为128位，密钥长度为128位，支持加密和解密。它主要应用于无线局域网和移动通信安全领域。

SM4 的工作流程包括：

1. **分组输入**  
   将128位明文分为4个32位的字，记为`X0, X1, X2, X3`。

2. **轮密钥生成**  
   从128位密钥派生出32个轮密钥`rk[0]`至`rk[31]`。密钥扩展采用非线性变换及固定常量，并用线性变换增强密钥随机性。

3. **32轮迭代加密**  
   每一轮迭代使用一个轮密钥，经过S盒非线性替换和线性变换，对4个字状态进行更新。  
   * 轮函数公式为：$ X_{i+4} = X_i \oplus T\bigl(X_{i+1} \oplus X_{i+2} \oplus X_{i+3} \oplus rk_i \bigr)$其中T函数结合S盒和线性变换。

4. **输出结果**  
经过32轮迭代，最终输出的4个32位字经过逆序组合形成128位密文。

5. **解密过程**  
解密与加密类似，只是轮密钥顺序相反。

SM4算法设计保证了强大的非线性和扩散性，抵抗常见的密码分析攻击。

---

## 二、SM4 优化思路说明

针对SM4的算法特点，优化重点主要在性能提升和效率改善：

### 1. 预计算T-表

- 将S盒和线性变换T函数组合成预计算的查找表（T-表），避免运行时重复计算S盒替换和多次旋转异或操作。
- 这样每轮迭代中T函数可以通过查表快速获得结果，大大减少计算量。

### 2. 循环展开与内联函数

- 将32轮迭代进行循环展开，减少循环控制开销。
- 关键函数如轮函数、循环左移等使用`inline`或宏定义，减少函数调用延迟。

### 3. 内存对齐和SIMD指令

由于 AES 指令集不能直接用于 SM4（这是因为 SM4 的轮函数、S盒、线性变换都与 AES 不同），因此需要间接通过 AES 指令集所使用的更底层的 SIMD 指令集（如 AVX2）来间接实现。

- 利用`alignas(32)`保证关键数组内存对齐，利于CPU预取和SIMD指令访问。
- 使用SIMD（如AVX2）并行处理多个数据块，提高批量加密的吞吐量。

### 4. 批量处理接口设计

- 设计批量加密和解密函数，减少单次调用开销，提高数据局部性和缓存命中率。

### 5. 轮密钥计算优化

- 在密钥扩展时使用预计算的T'-表，减少密钥扩展时的计算复杂度。
- 展开循环计算轮密钥，减少循环跳转。

### 6. 代码结构优化

- 避免不必要的内存拷贝和数据转换。
- 合理使用`std::vector`和数组，减少动态内存分配。

---
## 三、SM4 算法运行结果

以下是原始的 SM4 算法运行结果：
![项目1测试结果](../images/proj1test.png '项目1测试结果')

以下是经过优化的 SM4 算法运行结果：
![项目1优化测试结果](../images/proj1test2.png '项目1优化测试结果')

可以看到，经过优化， SM4 加密算法的性能有了十分显著的提升。

---
## 四、基于 SM4 的 SM4-GCM 工作模式原理和实现思路
SM4-GCM 是一种认证加密模式，它结合了国密SM4分组密码算法和GCM（Galois/Counter Mode）模式。其核心目标是同时提供数据的**机密性**（加密）和**真实性/完整性**（认证）。以下是其实现思路的关键步骤和核心组件：

### 4.1. 核心思路：
1.  **加密部分：** 使用 SM4 在 **CTR 模式** 下加密明文数据流。
2.  **认证部分：** 使用一个在伽罗瓦域 `GF(2^128)` 上定义的 **Universal Hash Function**，称为 **GHASH**，来计算一个消息认证码（GMAC）。GHASH 的输入包括：
    *   关联数据（AAD - Additional Authenticated Data）：不需要加密但需要验证其完整性的数据。
    *   密文（由 CTR 加密产生）。
    *   一个特殊的、由初始化向量（IV）和计数器初始值构造的初始认证块。

### 4.2. 关键组件详解：

1.  **初始化：**
    *   **输入：**
        *   `K`: SM4 密钥（128 位）。
        *   `IV`: 初始化向量（通常要求 96 位以获得最高效率和安全性，但也支持其他长度，需要经过 GHASH 预处理）。
        *   `AAD`: 关联数据（任意长度，可选）。
        *   `P`: 明文数据（任意长度）。
    *   **预计算：**
        *   **SM4 密钥扩展：** 使用 `K` 生成 SM4 加密所需的轮密钥。
        *   **生成初始计数器块 `J0`：**
            *   **如果 `IV` 是 96 位 (推荐)：** $J0 = IV || 0^{31} || 1$。即 IV 后拼接 31 个 `0` 和一个 `1`，构成一个 128 位块。最低 32 位用作计数器（从 `1` 开始）。
            *   **如果 `IV` 不是 96 位：** $J_0 = GHASH_H(IV || 0^{s})$。其中 $s = 128 * \lceil \frac{len(IV)}{128} - len(IV) \rceil $（填充到下一个完整块的比特数），`H` 是 `SM4_Encrypt(K, 0^128)`（即用 SM4 加密全零块得到的值）。这个 `J0` 本身还需要经过 `GHASH_H` 处理。
        *   **计算 `H`：** `H = SM4_Encrypt(K, 0^128)`。这是 GHASH 的核心乘数，是 SM4 加密一个全零块的结果。`H` 是一个 128 位的值。
        *   **初始化 GHASH 状态 `S`：** `S = 0^128` (全零)。

2.  **处理关联数据 (AAD)：**
    *   **目标：** 将 AAD 纳入认证标签的计算，确保其完整性。
    *   **步骤：**
        *   将 AAD 填充为 128 位块的倍数（如果长度不是倍数）。填充规则：附加尽可能少的 `0` 比特使其长度成为 128 位的倍数。
        *   将填充后的 AAD 分割成 128 位块：`A1, A2, ..., Am`。
        *   对于每个块 `Ai` (i 从 1 到 m)：
            *   `S = GHASH_H(S, Ai) = (S XOR Ai) * H mod P`
            *   其中 `*` 表示 `GF(2^128)` 上的乘法（通常使用不可约多项式 $P(x) = x^{128} + x^7 + x^2 + x + 1$，`H` 是步骤 1 计算出的值。

3.  **加密明文 (CTR 模式)：**
    *   **目标：** 使用 SM4-CTR 加密明文，生成密文。
    *   **步骤：**
        *   将明文 `P` 分割成 128 位块：`P1, P2, ..., Pn`。最后一个块可能不足 128 位。
        *   初始化计数器：`CTR = J0`。但注意 `J0` 的最低 32 位用作实际计数器部分（从 `1` 或 `2` 开始递增），高 96 位通常是 IV（或由其派生）。
        *   对于每个块 `i` (从 1 到 n)：
            *   计算计数器值：`CTRi = incr32(CTR)`。`incr32` 函数只增加 `CTR` 的最低有效 32 位（模 `2^32`），高位保持不变。*注意：`J0` 本身用于认证，第一个加密计数器通常是 `incr32(J0)`*。
            *   生成密钥流块：`KS_i = SM4_Encrypt(K, CTRi)`。
            *   生成密文块 `Ci`：
                *   对于完整块：`Ci = Pi XOR KS_i`。
                *   对于最后一个不完整块（长度 `u` 位）：`Ci = Pi XOR truncate(KS_i, u)`（取 `KS_i` 的前 `u` 位）。
        *   最终密文 `C = C1 || C2 || ... || Cn`。

4.  **处理密文 (用于认证)：**
    *   **目标：** 将生成的密文纳入认证标签的计算。
    *   **步骤：**
        *   将密文 `C` 填充为 128 位块的倍数（如果长度不是倍数）。填充规则与 AAD 相同：附加尽可能少的 `0` 比特。
        *   将填充后的密文分割成 128 位块：`C1, C2, ..., Cl`（注意这里的 `C` 块可能和加密步骤中的 `C` 块不同，因为经过了填充和重组）。
        *   对于每个块 `Ci` (i 从 1 到 l)：
            *   $S = GHASH_H(S, Ci) = (S XOR Ci) * H \mod P$（使用相同的 `H`）。

5.  **处理长度信息 (用于认证)：**
    *   **目标：** 将 AAD 和密文的*原始*长度（以比特为单位）纳入认证标签计算，防止填充或截断攻击。
    *   **步骤：**
        *   构造一个特殊的 128 位长度块 `Len`：
            *   `len(AAD)` = AAD 的原始长度（比特数）。
            *   `len(C)` = 密文的原始长度（比特数，*等于原始明文的长度*）。
            *   $Len = (len(AAD) * 8) || (len(C) * 8)$。即高 64 位存储 `len(AAD)` 的比特数，低 64 位存储 `len(C)` 的比特数。
        *   更新 GHASH 状态：$S = GHASH_H(S, Len) = (S\quad XOR\quad Len) * H \mod P$。

6.  **计算最终认证标签 (GMAC/T)：**
    *   **目标：** 生成一个固定大小的标签，用于验证数据的完整性和真实性。
    *   **步骤：**
        *   计算 `T_full = GHASH_H(S, J0)`。即用 `J0`（初始认证块）对当前的 GHASH 状态 `S` 进行最后的“加密”。
        *   更精确的公式：`T_full = S * H mod P XOR E(K, J0)`。其中 `E(K, J0) = SM4_Encrypt(K, J0)`。*(注意：在之前的 GHASH 步骤后，`S` 已经是累积的 GHASH 结果，这里与 `E(K, J0)` 异或是 GCM 规范的一部分)*。
        *   截取认证标签 `T`：通常取 `T_full` 的前 `t` 位（`t` 是需要的标签长度，通常为 96, 104, 112, 120 或 128 位）。`T = truncate(T_full, t)`。

7.  **输出：**
    *   密文 `C`。
    *   认证标签 `T`。

### 4.3. 解密和验证：
1.  使用相同的 `K` 和 `IV` 重新初始化过程。
2.  处理相同的 `AAD`（如果存在）。
3.  使用 SM4-CTR 模式解密 `C` 得到明文 `P'`。*（注意：此时尚未验证 `C` 或 `AAD` 是否被篡改）*。
4.  在处理完 `AAD` 和接收到的 `C` 之后，按照步骤 4 和 5 计算 GHASH 状态 `S'`。
5.  计算预期的认证标签 `T' = truncate(S' * H mod P XOR E(K, J0), t)`。
6.  将计算出的 `T'` 与接收到的 `T` 进行比较：
    *   如果 `T' == T`，则解密得到的明文 `P'` 和 `AAD` 是真实且完整的。
    *   如果 `T' != T`，则数据（`C` 或 `AAD`）在传输过程中被篡改，`P'` 无效，必须丢弃。

### 4.4. 对于该算法的特点阐述以及注意事项：

*   **并行性：** CTR 模式的加密/解密和 GHASH 计算都可以高度并行化（尤其是 GHASH 使用高效的 $GF(2^{128})$ 乘法实现时），性能优异。
*   **效率：** 对明文/密文和 AAD 只需要单次处理。
*   **IV 要求：** IV 必须是唯一的（对于同一个密钥）。强烈推荐使用 96 位 IV，因为它最安全且最高效（不需要经过 GHASH 预处理）。重复使用 IV 和密钥对会导致严重的安全漏洞。
*   **认证范围：** 同时保护了密文 `C` 和关联数据 `AAD` 的完整性和真实性。
*   **GHASH 核心：** $GF(2^{128})$ 上的乘法是 GCM 的核心操作，其高效实现（通常基于查表或硬件指令如 PCLMULQDQ）对整体性能至关重要。
*   **计数器管理：** 计数器只增加低 32 位，确保计数器块在单个消息内不会回绕（最大消息长度约为 $2^{32} * 16 = 68GB$）。跨消息必须使用不同的 IV。
*   **H 值：** `H = SM4_Encrypt(K, 0)` 是 GHASH 的核心密钥，必须保密。

---

## 五、基于 SM4 的 SM4-GCM 工作模式的运行结果

以下是 SM4-GCM 工作模式下的算法运行结果：
![项目1GCM测试结果](../images/proj1test3.png '项目1GCM测试结果')
可以看到，经过优化后 SM4-GCM 具有比较高的效率。

---

## 六、总结

SM4的优化主要聚焦在减少重复计算、提高数据并行度和利用CPU硬件特性。通过预计算查找表、循环展开、SIMD并行和内存对齐等方法，可以显著提升SM4的加解密性能，满足高性能安全通信的需求。

而 SM4-GCM 的实现思路是利用 SM4-CTR 提供高效的流式加密，同时利用基于 GF($2^{128}$) 乘法的 GHASH 函数，将 IV（J0）、AAD、密文和它们的原始长度信息混合在一起，最终通过一个 SM4 加密步骤（E(K, J0)）生成认证标签。这种组合在保证机密性和强认证性的同时，提供了优异的性能。实现时需要特别注意 IV 的唯一性和 `H` 值的安全计算。


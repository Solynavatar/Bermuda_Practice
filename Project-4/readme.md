# Project 4

## 一、SM3 算法大致原理

SM3 是中国国家密码管理局发布的密码杂凑函数标准，类似于 SHA-256，主要用于信息安全领域的数据完整性保护和数字签名。

SM3 的核心流程包括：

1. **消息填充**  
   输入消息首先按照特定规则填充，使得消息长度满足 512 位（64 字节）的整数倍，且填充后消息长度信息被附加。

2. **消息分组**  
   将填充后的消息分割成若干个 512 位的消息块。

3. **消息扩展**  
   对每个消息块生成 68 个 32 位字 `W[i]` 和 64 个 32 位字 `W1[i]`，这是消息调度部分，用于后续压缩函数计算。

4. **迭代压缩**  
   利用八个 32 位寄存器（`A, B, C, D, E, F, G, H`）初始化状态值，针对每个消息块执行64轮迭代运算，通过布尔函数、置换函数和轮常量，混合消息调度生成的 `W` 和 `W1`。

5. **输出结果**  
   所有消息块迭代完成后，将最后的状态值拼接形成256位（32字节）的哈希值。

SM3算法设计确保了抗碰撞性和雪崩效应，是一种安全的哈希算法。

---

## 二、优化思路说明

在原始SM3实现基础上，我尝试了以下几方面的优化：

### 1. 减少不必要的内存拷贝

- 通过直接使用`uint8_t`指针操作输入数据，避免中间临时数组的重复构造和拷贝。
- 预先分配好消息和哈希缓存，避免动态扩容带来的性能开销。

### 2. 减少函数调用开销

- 将部分小的内联函数（例如`ROTL`、`P0`、`P1`）使用`inline`修饰，降低函数调用成本。
- 采用简单的宏或内联函数替代复杂的函数结构。

### 3. 批量处理逻辑封装

- 设计批量处理函数`sm3_batch`，减少循环控制逻辑开销，提高代码结构清晰度。
- 对消息处理进行连续内存访问，提升缓存局部性。

### 4. 使用合适的编译优化选项

- 编译时使用`-O3`开启最高等级优化，自动进行循环展开、指令调度等。

### 5. 预计算常量和减少冗余运算

- 使用静态`constexpr`数组存储轮常量`T[i]`，避免运行时计算。
- 合理设计消息扩展算法，减少重复计算。

---

## 三、运行结果

以下是原始的 SM3 算法运行结果：
![项目4测试结果](../images/proj4test.png '项目4测试结果')

以下是经过优化的 SM3 算法运行结果：
![项目4优化测试结果](../images/proj4test2.png '项目4优化测试结果')

可以看到，经过优化， SM3 加密算法的性能有了十分显著的提升。

---

## 四、总结

SM3算法本身结构较为复杂，优化重点在于提高数据处理的效率，减少冗余操作和函数调用，并利用硬件并行能力。当前优化方案主要是代码结构和内存管理的改进，提升一定性能。进一步加速需要结合SIMD指令和多线程并行。


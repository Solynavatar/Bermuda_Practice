# Project 5

## 一、SM2算法大致原理

SM2 是我国自主设计的基于 **椭圆曲线密码学（ECC）** 的公钥密码算法，由国家密码管理局发布（GB/T 32918-2016），主要应用于：数字签名，数据加密和密钥交换等领域。

SM2 的加密算法大致流程如下：

1. **密钥生成**

   * 选取一条椭圆曲线和基点 $G$
   * 随机生成私钥 $d$，计算公钥：

     $$
     P = d \cdot G
     $$

2. **加密**

   * 随机选择整数 $k$
   * 计算曲线点：

     $$
     C_1 = k \cdot G
     $$
   * 根据 $k \cdot P$ 生成密钥流，对明文 $M$ 加密得到：

     $$
     C_2
     $$
   * 根据 $k \cdot P$ 生成消息摘要：

     $$
     C_3
     $$
   * 拼接为最终密文：

     $$
     C = C_1 \| C_2 \| C_3
     $$

3. **解密**

   * 从密文提取 $C_1$，计算：

     $$
     d \cdot C_1 = k \cdot P
     $$
   * 用 $k \cdot P$ 恢复明文 $M$
   * 校验消息摘要 $C_3$

其本质为通过椭圆曲线点乘和对称加密相结合实现机密性与完整性。

---

## 二、优化 SM2 算法的思路

由于 Python 本身执行较慢，优化思路主要包括：

### 1. **批量处理**

* 一次性加解密多条消息，而不是循环单次调用。
* 减少 Python 与底层之间的交互。

### 2. **密钥复用**

* 大量加解密时，只生成一次私钥/公钥对。
* 避免每次重新初始化密钥对象。

### 3. **减少循环体内开销**

* 将编码、哈希等准备工作移到循环外。
* 在循环内仅做核心加解密运算。

### 4. **底层加速**

* 使用 C/C++ 等更底层的语言实现或国密专用硬件/库，如 `gmssl`。
    * 本实验由于考虑到使用 C/C++ 等更加底层的语言实现起来会相当的繁琐，因此使用 Python 完成对 SM2 算法的实现。
* 对大规模批量数据加解密可用 SIMD 或调用 GPU 加速。

## 三、实验结果


以下依次是原始的 SM3 算法运行结果和经过优化的 SM3 算法运行结果：
![项目5测试结果](../images/proj5test.png '项目5测试结果')

可以看到，经过优化， SM2 加密算法的性能得到了的提升。

## 四、总结

SM2 是一种基于椭圆曲线密码学的中国国家标准公钥算法，结合了对称加密与哈希校验，兼具安全性和性能。在 Python 中实现 SM2 时常规实现简单直接，但在大规模或高频调用场景下存在性能瓶颈。优化版本通过**批量处理**、**密钥复用**与**循环外计算**，可明显降低运行时间与资源消耗。

此外，若想要进一步提升它的性能，就必须要更接近底层去进行优化才有可能使算法效率得到明显的提升。

